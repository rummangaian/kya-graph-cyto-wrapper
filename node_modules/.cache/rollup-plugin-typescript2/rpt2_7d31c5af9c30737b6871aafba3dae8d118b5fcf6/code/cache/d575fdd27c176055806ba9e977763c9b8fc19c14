{"code":"import cytoscape from 'cytoscape';\nimport { cytoscapeDefaultStyles } from './cytoscapeDataUtils/defaultStyles';\n// @ts-ignore\nimport cola from 'cytoscape-cola';\n// @ts-ignore\nimport euler from 'cytoscape-euler';\nimport colaDefaultLayout from './cytoscapeDataUtils/colaLayoutDefault';\nimport themeData from './cytoscapeDataUtils/themeData';\ncytoscape.use(cola);\ncytoscape.use(euler);\n/**\n * Resolves color tokens to hex values for Cytoscape\n * @param tokenValue - The token value (e.g., \"token:color-blue-500\")\n * @param theme - The theme to use (default: \"Light\")\n * @returns Hex color value or original value if not a token\n */\nfunction resolveCytoscapeColorToken(tokenValue, theme = 'Light') {\n    if (typeof tokenValue !== 'string' || !tokenValue.startsWith('token:')) {\n        return tokenValue;\n    }\n    const tokenKey = tokenValue.slice(6); // Remove 'token:' prefix\n    // First check in the specified theme\n    if (themeData[theme] && themeData[theme][tokenKey]) {\n        return themeData[theme][tokenKey];\n    }\n    // Fallback to Light theme if not found in current theme\n    if (theme !== 'Light' && themeData.Light && themeData.Light[tokenKey]) {\n        return themeData.Light[tokenKey];\n    }\n    // If still not found, check common color mappings\n    const commonColors = {\n        'color-white': '#ffffff',\n        'color-black': '#000000',\n        'color-blue-50': '#ebf5ff',\n        'color-blue-100': '#e1effe',\n        'color-blue-200': '#c3ddfd',\n        'color-blue-300': '#a4cafe',\n        'color-blue-400': '#76a9fa',\n        'color-blue-500': '#3f83f8',\n        'color-blue-600': '#1c64f2',\n        'color-blue-700': '#1a56db',\n        'color-blue-800': '#1e429f',\n        'color-blue-900': '#233876',\n        'color-gray-50': '#f8fafc',\n        'color-gray-100': '#eef2f6',\n        'color-gray-200': '#e3e8ef',\n        'color-gray-300': '#cdd5df',\n        'color-gray-400': '#9aa4b2',\n        'color-gray-500': '#697586',\n        'color-gray-600': '#4b5565',\n        'color-gray-700': '#364152',\n        'color-gray-800': '#202939',\n        'color-gray-900': '#121926',\n        'color-red-50': '#fdf2f2',\n        'color-red-100': '#fde8e8',\n        'color-red-200': '#fbd5d5',\n        'color-red-300': '#f8b4b4',\n        'color-red-400': '#f98080',\n        'color-red-500': '#f05252',\n        'color-red-600': '#e02424',\n        'color-red-700': '#c81e1e',\n        'color-red-800': '#9b1c1c',\n        'color-red-900': '#771d1d',\n        'color-green-50': '#f3faf7',\n        'color-green-100': '#def7ec',\n        'color-green-200': '#bcf0da',\n        'color-green-300': '#84e1bc',\n        'color-green-400': '#31c48d',\n        'color-green-500': '#0e9f6e',\n        'color-green-600': '#057a55',\n        'color-green-700': '#046c4e',\n        'color-green-800': '#03543f',\n        'color-green-900': '#014737',\n        'color-indigo-50': '#f0f5ff',\n        'color-indigo-100': '#e5edff',\n        'color-indigo-200': '#cddbfe',\n        'color-indigo-300': '#b4c6fc',\n        'color-indigo-400': '#8da2fb',\n        'color-indigo-500': '#6875f5',\n        'color-indigo-600': '#5850ec',\n        'color-indigo-700': '#5145cd',\n        'color-indigo-800': '#42389d',\n        'color-indigo-900': '#362f78',\n        'color-yellow-50': '#fdfdea',\n        'color-yellow-100': '#fdf6b2',\n        'color-yellow-200': '#fce96a',\n        'color-yellow-300': '#faca15',\n        'color-yellow-400': '#e3a008',\n        'color-yellow-500': '#c27803',\n        'color-yellow-600': '#9f580a',\n        'color-yellow-700': '#8e4b10',\n        'color-yellow-800': '#723b13',\n        'color-yellow-900': '#633112',\n        // Semantic colors\n        'color-text-primary': '#1a1a1a',\n        'color-text-secondary': '#4b5565',\n        'color-text-primary-inverse': '#ffffff',\n        'color-bg-primary': '#ffffff',\n        'color-bg-secondary': '#f8fafc',\n    };\n    if (commonColors[tokenKey]) {\n        return commonColors[tokenKey];\n    }\n    // If token not found, return original value and log warning\n    console.warn(`Cytoscape color token not found: ${tokenValue}`);\n    return tokenValue;\n}\n/**\n * Processes Cytoscape style configuration to resolve color tokens\n * @param styleConfig - The style configuration array\n * @param theme - The theme to use for token resolution\n * @returns Processed style configuration with resolved color tokens\n */\nfunction processColorTokens(styleConfig, theme = 'Light') {\n    if (!Array.isArray(styleConfig)) {\n        return styleConfig;\n    }\n    return styleConfig.map(rule => {\n        if (!rule.style) {\n            return rule;\n        }\n        const processedStyle = Object.assign({}, rule.style);\n        // Define color properties that should be processed for tokens\n        const colorProperties = [\n            'background-color',\n            'color',\n            'line-color',\n            'target-arrow-color',\n            'source-arrow-color',\n            'border-color',\n            'text-outline-color',\n            'overlay-color',\n            'underlay-color',\n        ];\n        // Process each color property\n        colorProperties.forEach(prop => {\n            if (processedStyle[prop]) {\n                const value = processedStyle[prop];\n                // Check if the value is a token reference\n                if (typeof value === 'string' && value.startsWith('token:')) {\n                    processedStyle[prop] = resolveCytoscapeColorToken(value, theme);\n                }\n            }\n        });\n        return Object.assign(Object.assign({}, rule), { style: processedStyle });\n    });\n}\nexport class CytoscapeService {\n    constructor() {\n        this.cy = null;\n        this.container = null;\n        this.selectedElement = {};\n        this.cyConfig = {};\n        this.eventListeners = [];\n        this.isDestroyed = false;\n        this.currentTheme = 'Light';\n        this.infoPanel = null;\n        this.infoPanelData = null;\n        this._isInfoPanelVisible = false;\n    }\n    init(context, config = {}) {\n        // Handle string ID by finding the element\n        let containerElement;\n        if (typeof context === 'string') {\n            containerElement = document.getElementById(context);\n            if (!containerElement) {\n                console.error(`Container element with ID '${context}' not found`);\n                return;\n            }\n        }\n        else {\n            containerElement = context;\n        }\n        if (!this.container || this.container !== containerElement) {\n            this.container = containerElement;\n            // Set proper CSS for the container to prevent infinite scroll\n            this.container.style.cssText = `\n        width: 100%;\n        height: 100%;\n        min-height: 400px;\n        position: relative;\n        overflow: hidden;\n        border: 1px solid #e0e0e0;\n        border-radius: 8px;\n        background: #ffffff;\n      `;\n        }\n        // Process style configuration to resolve color tokens\n        const processedStyles = config.style\n            ? processColorTokens(config.style, this.currentTheme)\n            : processColorTokens(cytoscapeDefaultStyles, this.currentTheme);\n        // Default configuration\n        const defaultConfig = {\n            container: this.container,\n            elements: config.elements || [],\n            style: processedStyles,\n            layout: config.layout || colaDefaultLayout,\n            // Add zoom constraints to prevent infinite scroll\n            minZoom: config.minZoom || 0.1,\n            maxZoom: config.maxZoom || 10,\n            zoomingEnabled: config.zoomingEnabled !== false,\n            userZoomingEnabled: config.userZoomingEnabled !== false,\n            panningEnabled: config.panningEnabled !== false,\n            userPanningEnabled: config.userPanningEnabled !== false,\n            boxSelectionEnabled: config.boxSelectionEnabled !== false,\n            autoungrabify: config.autoungrabify !== false,\n            autounselectify: config.autounselectify !== false,\n        };\n        // Merge user config with defaults (excluding style as it's already processed)\n        const finalConfig = Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { style: processedStyles });\n        this.cyConfig = finalConfig;\n        this.cy = cytoscape(finalConfig);\n        // Clear existing event listeners\n        this.removeAllEventListeners();\n        // Add node click handler\n        const nodeClickHandler = (evt) => {\n            var _a, _b, _c;\n            let nodeData = (_a = evt.target) === null || _a === void 0 ? void 0 : _a.data();\n            if (nodeData.id) {\n                this.selectedElement = (_b = evt.target) === null || _b === void 0 ? void 0 : _b.data();\n                // Get node position for popup placement\n                const node = evt.target;\n                const nodePos = node.renderedPosition();\n                const containerRect = (_c = this.container) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect();\n                if (containerRect) {\n                    const position = {\n                        x: containerRect.left + nodePos.x,\n                        y: containerRect.top + nodePos.y,\n                    };\n                    // Show info panel with node data if enabled\n                    if (config.enableInfoPanel !== false) {\n                        this.showInfoPanel({\n                            title: `Node: ${nodeData.label || nodeData.id}`,\n                            content: nodeData,\n                            type: 'node',\n                            timestamp: Date.now(),\n                            position: position,\n                        });\n                    }\n                }\n            }\n        };\n        this.cy.on('tap', 'node', nodeClickHandler);\n        this.eventListeners.push({\n            event: 'tap',\n            selector: 'node',\n            handler: nodeClickHandler,\n        });\n        // Add edge click handler\n        const edgeClickHandler = (evt) => {\n            var _a, _b, _c;\n            let edgeData = (_a = evt.target) === null || _a === void 0 ? void 0 : _a.data();\n            if (edgeData.id) {\n                this.selectedElement = (_b = evt.target) === null || _b === void 0 ? void 0 : _b.data();\n                // Get edge position for popup placement\n                const edge = evt.target;\n                const edgePos = edge.renderedPosition();\n                const containerRect = (_c = this.container) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect();\n                if (containerRect) {\n                    const position = {\n                        x: containerRect.left + edgePos.x,\n                        y: containerRect.top + edgePos.y,\n                    };\n                    // Show info panel with edge data if enabled\n                    if (config.enableInfoPanel !== false) {\n                        this.showInfoPanel({\n                            title: `Edge: ${edgeData.label || edgeData.id}`,\n                            content: edgeData,\n                            type: 'edge',\n                            timestamp: Date.now(),\n                            position: position,\n                        });\n                    }\n                }\n            }\n        };\n        this.cy.on('tap', 'edge', edgeClickHandler);\n        this.eventListeners.push({\n            event: 'tap',\n            selector: 'edge',\n            handler: edgeClickHandler,\n        });\n        // Add background click handler to hide info panel\n        const backgroundClickHandler = (evt) => {\n            if (evt.target === this.cy) {\n                this.hideInfoPanel();\n            }\n        };\n        this.cy.on('tap', backgroundClickHandler);\n        this.eventListeners.push({\n            event: 'tap',\n            handler: backgroundClickHandler,\n        });\n        // Create info panel if enabled\n        if (config.enableInfoPanel !== false) {\n            this.createInfoPanel(config.infoPanelPosition || 'top-right');\n        }\n        // Add zoom event handler to prevent layout issues\n        const zoomHandler = () => {\n            // Ensure the container maintains proper dimensions during zoom\n            if (this.container && this.cy) {\n                const containerRect = this.container.getBoundingClientRect();\n                if (containerRect.width > 0 && containerRect.height > 0) {\n                    this.cy.resize();\n                }\n            }\n        };\n        this.cy.on('zoom', zoomHandler);\n        this.eventListeners.push({\n            event: 'zoom',\n            handler: zoomHandler,\n        });\n        return this.cy;\n    }\n    /**\n     * Creates the info panel element\n     */\n    createInfoPanel(position = 'top-right') {\n        if (this.infoPanel) {\n            return; // Already exists\n        }\n        this.infoPanel = document.createElement('div');\n        this.infoPanel.id = 'cytoscape-info-panel';\n        this.infoPanel.style.cssText = `\n      position: absolute;\n      z-index: 1000;\n      background: rgba(255, 255, 255, 0.95);\n      border: 1px solid #e0e0e0;\n      border-radius: 8px;\n      padding: 16px;\n      min-width: 350px;\n      max-width: 450px;\n      max-height: 500px;\n      overflow-y: auto;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n      font-family: 'Plus Jakarta Sans', sans-serif;\n      font-size: 12px;\n      font-weight: 300;\n      line-height: 1.5;\n      opacity: 0;\n      transform: translateY(-10px);\n      transition: opacity 0.3s ease, transform 0.3s ease;\n      backdrop-filter: blur(10px);\n    `;\n        // Initial position (will be updated when showing)\n        this.updateInfoPanelPosition(position);\n        // Add close button\n        const closeButton = document.createElement('button');\n        closeButton.innerHTML = 'Ã—';\n        closeButton.style.cssText = `\n      position: absolute;\n      top: 8px;\n      right: 8px;\n      background: none;\n      border: none;\n      font-size: 18px;\n      font-weight: bold;\n      cursor: pointer;\n      color: #666;\n      width: 24px;\n      height: 24px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      border-radius: 50%;\n      transition: background-color 0.2s ease;\n    `;\n        closeButton.addEventListener('mouseenter', () => {\n            closeButton.style.backgroundColor = '#f0f0f0';\n        });\n        closeButton.addEventListener('mouseleave', () => {\n            closeButton.style.backgroundColor = 'transparent';\n        });\n        closeButton.addEventListener('click', () => {\n            this.hideInfoPanel();\n        });\n        this.infoPanel.appendChild(closeButton);\n        // Add arrow element\n        const arrow = document.createElement('div');\n        arrow.id = 'cytoscape-info-panel-arrow';\n        arrow.style.cssText = `\n      position: absolute;\n      width: 0;\n      height: 0;\n      border: 6px solid transparent;\n      pointer-events: none;\n      z-index: 1001;\n    `;\n        this.infoPanel.appendChild(arrow);\n        // Add to document body to avoid layout issues\n        document.body.appendChild(this.infoPanel);\n    }\n    /**\n     * Positions the info panel near the clicked element\n     */\n    positionPanelNearElement(elementPosition) {\n        if (!this.infoPanel)\n            return;\n        const panelRect = this.infoPanel.getBoundingClientRect();\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        const margin = 16;\n        const arrowOffset = 12; // Distance from edge for arrow\n        // Calculate initial position (top-left of panel aligns with node)\n        let left = elementPosition.x;\n        let top = elementPosition.y;\n        let arrowPosition = 'left'; // Default arrow position\n        // Check if panel would go off the right edge\n        if (left + panelRect.width > viewportWidth - margin) {\n            left = elementPosition.x - panelRect.width; // Position to the left of node\n            arrowPosition = 'right';\n        }\n        // Check if panel would go off the left edge\n        if (left < margin) {\n            left = margin;\n            arrowPosition = 'left';\n        }\n        // Check if panel would go off the bottom edge\n        if (top + panelRect.height > viewportHeight - margin) {\n            top = viewportHeight - panelRect.height - margin;\n            arrowPosition = arrowPosition === 'left' ? 'left' : 'right';\n        }\n        // Check if panel would go off the top edge\n        if (top < margin) {\n            top = margin;\n            arrowPosition = arrowPosition === 'left' ? 'left' : 'right';\n        }\n        // Apply the calculated position\n        this.infoPanel.style.left = `${left}px`;\n        this.infoPanel.style.top = `${top}px`;\n        this.infoPanel.style.right = 'auto';\n        this.infoPanel.style.bottom = 'auto';\n        // Update arrow position\n        this.updateArrowPosition(arrowPosition, elementPosition, left, top);\n    }\n    /**\n     * Updates the arrow position and direction\n     */\n    updateArrowPosition(arrowPosition, elementPosition, panelLeft, panelTop) {\n        if (!this.infoPanel)\n            return;\n        const arrow = this.infoPanel.querySelector('#cytoscape-info-panel-arrow');\n        if (!arrow)\n            return;\n        const panelRect = this.infoPanel.getBoundingClientRect();\n        const arrowSize = 6;\n        if (arrowPosition === 'left') {\n            // Arrow pointing left (panel is to the right of the node)\n            arrow.style.left = '-12px';\n            arrow.style.top = '20px';\n            arrow.style.borderRightColor = 'rgba(255, 255, 255, 0.95)';\n            arrow.style.borderLeftColor = 'transparent';\n            arrow.style.borderTopColor = 'transparent';\n            arrow.style.borderBottomColor = 'transparent';\n        }\n        else {\n            // Arrow pointing right (panel is to the left of the node)\n            arrow.style.left = `${panelRect.width}px`;\n            arrow.style.top = '20px';\n            arrow.style.borderLeftColor = 'rgba(255, 255, 255, 0.95)';\n            arrow.style.borderRightColor = 'transparent';\n            arrow.style.borderTopColor = 'transparent';\n            arrow.style.borderBottomColor = 'transparent';\n        }\n    }\n    /**\n     * Updates the position of the info panel\n     */\n    updateInfoPanelPosition(position) {\n        if (!this.infoPanel)\n            return;\n        const margin = 16;\n        switch (position) {\n            case 'top-left':\n                this.infoPanel.style.top = `${margin}px`;\n                this.infoPanel.style.left = `${margin}px`;\n                break;\n            case 'top-right':\n                this.infoPanel.style.top = `${margin}px`;\n                this.infoPanel.style.right = `${margin}px`;\n                break;\n            case 'bottom-left':\n                this.infoPanel.style.bottom = `${margin}px`;\n                this.infoPanel.style.left = `${margin}px`;\n                break;\n            case 'bottom-right':\n                this.infoPanel.style.bottom = `${margin}px`;\n                this.infoPanel.style.right = `${margin}px`;\n                break;\n            default:\n                this.infoPanel.style.top = `${margin}px`;\n                this.infoPanel.style.right = `${margin}px`;\n        }\n    }\n    /**\n     * Shows the info panel with the provided data\n     */\n    showInfoPanel(data) {\n        if (!this.infoPanel) {\n            this.createInfoPanel();\n        }\n        this.infoPanelData = data;\n        this.updateInfoPanelContent(data);\n        this._isInfoPanelVisible = true;\n        // Position the panel next to the clicked element if position is provided\n        if (data.position && this.infoPanel) {\n            this.positionPanelNearElement(data.position);\n        }\n        // Show the panel with animation\n        if (this.infoPanel) {\n            this.infoPanel.style.opacity = '1';\n            this.infoPanel.style.transform = 'translateY(0)';\n        }\n    }\n    /**\n     * Hides the info panel\n     */\n    hideInfoPanel() {\n        if (!this.infoPanel)\n            return;\n        this._isInfoPanelVisible = false;\n        this.infoPanel.style.opacity = '0';\n        this.infoPanel.style.transform = 'translateY(-10px)';\n    }\n    /**\n     * Updates the content of the info panel\n     */\n    updateInfoPanelContent(data) {\n        if (!this.infoPanel)\n            return;\n        // Clear existing content (except close button)\n        const closeButton = this.infoPanel.querySelector('button');\n        this.infoPanel.innerHTML = '';\n        if (closeButton) {\n            this.infoPanel.appendChild(closeButton);\n        }\n        // Create title\n        if (data.title) {\n            const title = document.createElement('h3');\n            title.textContent = data.title;\n            title.style.cssText = `\n        margin: 0 0 12px 0;\n        font-family: 'Plus Jakarta Sans', sans-serif;\n        font-size: 14px;\n        font-weight: 500;\n        color: #333;\n        border-bottom: 1px solid #e0e0e0;\n        padding-bottom: 8px;\n      `;\n            this.infoPanel.appendChild(title);\n        }\n        // Create content container\n        const contentContainer = document.createElement('div');\n        contentContainer.style.cssText = `\n      max-height: 400px;\n      overflow-y: auto;\n      padding-right: 8px;\n    `;\n        // Format and display the content\n        if (typeof data.content === 'object') {\n            const formattedContent = this.formatJsonContent(data.content, data.type);\n            contentContainer.innerHTML = formattedContent;\n        }\n        else {\n            const textContent = document.createElement('p');\n            textContent.textContent = String(data.content);\n            textContent.style.cssText = `\n        margin: 0;\n        color: #666;\n      `;\n            contentContainer.appendChild(textContent);\n        }\n        this.infoPanel.appendChild(contentContainer);\n    }\n    /**\n     * Formats JSON content for display in a two-column layout\n     */\n    formatJsonContent(content, type) {\n        const formatValue = (value) => {\n            if (value === null || value === undefined) {\n                return '<span style=\"color: #999;\">null</span>';\n            }\n            if (typeof value === 'string') {\n                return `<span style=\"color: #333;\">${value}</span>`;\n            }\n            if (typeof value === 'number') {\n                return `<span style=\"color: #333;\">${value}</span>`;\n            }\n            if (typeof value === 'boolean') {\n                return `<span style=\"color: #333;\">${value}</span>`;\n            }\n            if (Array.isArray(value)) {\n                return `<span style=\"color: #333;\">${value.join(', ')}</span>`;\n            }\n            if (typeof value === 'object') {\n                // For nested objects, create a nested two-column layout\n                const items = Object.entries(value)\n                    .map(([key, val]) => {\n                    const formattedVal = formatValue(val);\n                    return `\n              <div style=\"display: flex; margin-bottom: 8px; align-items: flex-start;\">\n                <div style=\"flex: 0 0 120px; color: #666; font-family: 'Plus Jakarta Sans', sans-serif; font-size: 11px; font-weight: 300; padding-right: 12px;\">\n                  ${this.capitalizeFirst(key)}:\n                </div>\n                <div style=\"flex: 1; color: #333; font-family: 'Plus Jakarta Sans', sans-serif; font-size: 11px; font-weight: 300; word-break: break-word;\">\n                  ${formattedVal}\n                </div>\n              </div>\n            `;\n                })\n                    .join('');\n                return `<div style=\"margin-left: 8px;\">${items}</div>`;\n            }\n            return String(value);\n        };\n        // Create two-column layout for the main content\n        const items = Object.entries(content)\n            .map(([key, value]) => {\n            const formattedValue = formatValue(value);\n            return `\n          <div style=\"display: flex; margin-bottom: 12px; align-items: flex-start;\">\n            <div style=\"flex: 0 0 120px; color: #666; font-family: 'Plus Jakarta Sans', sans-serif; font-size: 11px; font-weight: 300; padding-right: 12px;\">\n              ${this.capitalizeFirst(key)}:\n            </div>\n            <div style=\"flex: 1; color: #333; font-family: 'Plus Jakarta Sans', sans-serif; font-size: 11px; font-weight: 300; word-break: break-word;\">\n              ${formattedValue}\n            </div>\n          </div>\n        `;\n        })\n            .join('');\n        return `<div style=\"font-family: 'Plus Jakarta Sans', sans-serif; font-size: 11px; font-weight: 300; line-height: 1.4;\">${items}</div>`;\n    }\n    /**\n     * Capitalizes the first letter of a string\n     */\n    capitalizeFirst(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n    /**\n     * Updates the info panel with new data\n     */\n    updateInfoPanel(data) {\n        if (this._isInfoPanelVisible) {\n            this.updateInfoPanelContent(data);\n            this.infoPanelData = data;\n        }\n    }\n    /**\n     * Sets the position of the info panel\n     */\n    setInfoPanelPosition(position) {\n        this.updateInfoPanelPosition(position);\n    }\n    /**\n     * Gets the current info panel data\n     */\n    getInfoPanelData() {\n        return this.infoPanelData;\n    }\n    /**\n     * Checks if the info panel is visible\n     */\n    isInfoPanelVisible() {\n        return this._isInfoPanelVisible;\n    }\n    elementClick(context) {\n        if (this.cy) {\n            return this.selectedElement;\n        }\n    }\n    updateData(context, elements) {\n        if (this.cy) {\n            this.cy.elements().remove();\n            this.cy.add(elements);\n            this.cy.layout(Object.assign({}, this.cyConfig.layout)).run();\n        }\n    }\n    setZoomLevel(context, distance) {\n        if (!this.cy)\n            return;\n        let numericDistance = Number(distance);\n        if (isNaN(numericDistance) || numericDistance <= 0)\n            return;\n        const newZoomLevel = numericDistance / 100;\n        // Smooth animated zoom toward graph center\n        this.cy.animate({\n            zoom: newZoomLevel,\n            center: { eles: this.cy.elements() },\n            duration: 1000,\n        });\n    }\n    getInstance(context) {\n        return this.cy;\n    }\n    destroy(context) {\n        if (this.isDestroyed) {\n            console.warn('CytoscapeService is already destroyed');\n            return;\n        }\n        // Remove all event listeners first\n        this.removeAllEventListeners();\n        // Remove info panel from document body\n        if (this.infoPanel) {\n            if (document.body.contains(this.infoPanel)) {\n                document.body.removeChild(this.infoPanel);\n            }\n            this.infoPanel = null;\n        }\n        // Destroy Cytoscape instance\n        if (this.cy) {\n            try {\n                this.cy.destroy();\n            }\n            catch (error) {\n                console.error('Error destroying Cytoscape instance:', error);\n            }\n            this.cy = null;\n        }\n        // Clear container\n        if (this.container) {\n            this.container.innerHTML = '';\n            this.container = null;\n        }\n        // Clear references\n        this.selectedElement = {};\n        this.cyConfig = {};\n        this.infoPanelData = null;\n        this._isInfoPanelVisible = false;\n        this.isDestroyed = true;\n    }\n    remove() {\n        this.destroy();\n    }\n    clear() {\n        if (this.cy) {\n            // Clear all elements from the graph\n            this.cy.elements().remove();\n            // Reset zoom and pan\n            this.cy.zoom(1);\n            this.cy.pan({ x: 0, y: 0 });\n            // Clear selection\n            this.cy.elements().unselect();\n        }\n        // Clear selected element and hide info panel\n        this.selectedElement = {};\n        this.hideInfoPanel();\n    }\n    dispose() {\n        // Remove all event listeners\n        this.removeAllEventListeners();\n        // Clear all data\n        this.clear();\n        // Destroy the instance\n        this.destroy();\n    }\n    removeAllEventListeners() {\n        if (this.cy && this.eventListeners.length > 0) {\n            this.eventListeners.forEach(listener => {\n                try {\n                    if (listener.selector) {\n                        this.cy.off(listener.event, listener.selector);\n                    }\n                    else {\n                        this.cy.off(listener.event);\n                    }\n                }\n                catch (error) {\n                    console.error(`Error removing event listener ${listener.event}:`, error);\n                }\n            });\n            this.eventListeners = [];\n        }\n    }\n    // Utility methods\n    fit() {\n        if (this.cy) {\n            this.cy.fit();\n        }\n    }\n    center() {\n        if (this.cy) {\n            this.cy.center();\n        }\n    }\n    zoom(level) {\n        if (this.cy) {\n            this.cy.zoom(level);\n        }\n    }\n    pan(position) {\n        if (this.cy) {\n            this.cy.pan(position);\n        }\n    }\n    runLayout(layoutOptions) {\n        if (this.cy) {\n            const layout = layoutOptions || { name: 'cose' };\n            this.cy.layout(layout).run();\n        }\n    }\n    getSelectedElements() {\n        if (!this.cy)\n            return [];\n        return this.cy.$(':selected').toArray();\n    }\n    selectElement(elementId) {\n        if (this.cy) {\n            this.cy.getElementById(elementId).select();\n        }\n    }\n    unselectAll() {\n        if (this.cy) {\n            this.cy.elements().unselect();\n        }\n    }\n    // Export/Import functionality\n    exportData() {\n        if (!this.cy)\n            return null;\n        return this.cy.json();\n    }\n    importData(data) {\n        if (this.cy && data) {\n            this.cy.json(data);\n        }\n    }\n    // Style and theming utilities\n    updateStyles(newStyles) {\n        if (this.cy) {\n            const processedStyles = processColorTokens(newStyles, this.currentTheme);\n            this.cy.style(processedStyles);\n        }\n    }\n    updateElementStyle(elementSelector, newStyle) {\n        if (this.cy) {\n            // Process color tokens in the style object\n            const processedStyle = Object.assign({}, newStyle);\n            const colorProperties = [\n                'background-color',\n                'color',\n                'line-color',\n                'target-arrow-color',\n                'source-arrow-color',\n                'border-color',\n                'text-outline-color',\n                'overlay-color',\n                'underlay-color',\n            ];\n            colorProperties.forEach(prop => {\n                if (processedStyle[prop] &&\n                    typeof processedStyle[prop] === 'string' &&\n                    processedStyle[prop].startsWith('token:')) {\n                    processedStyle[prop] = resolveCytoscapeColorToken(processedStyle[prop], this.currentTheme);\n                }\n            });\n            this.cy.style().selector(elementSelector).style(processedStyle).update();\n        }\n    }\n    setTheme(theme) {\n        if (!this.cy)\n            return;\n        // Update current theme\n        this.currentTheme =\n            theme === 'light' ? 'Light' : theme === 'dark' ? 'Dark' : theme;\n        // Define theme-specific color mappings using tokens (will be resolved later)\n        const themes = {\n            light: {\n                'node-bg': 'token:color-blue-500',\n                'node-text': 'token:color-text-primary-inverse',\n                'node-selected-bg': 'token:color-red-500',\n                'node-selected-border': 'token:color-red-600',\n                'edge-line': 'token:color-gray-300',\n                'edge-arrow': 'token:color-gray-300',\n                'edge-text': 'token:color-text-secondary',\n                'edge-selected': 'token:color-red-500',\n            },\n            dark: {\n                'node-bg': 'token:color-blue-400',\n                'node-text': 'token:color-text-primary-inverse',\n                'node-selected-bg': 'token:color-red-400',\n                'node-selected-border': 'token:color-red-500',\n                'edge-line': 'token:color-gray-500',\n                'edge-arrow': 'token:color-gray-500',\n                'edge-text': 'token:color-text-primary-inverse',\n                'edge-selected': 'token:color-red-400',\n            },\n        };\n        const themeColors = themes[theme] || themes.light;\n        const themedStyles = [\n            {\n                selector: 'node',\n                style: {\n                    'background-color': themeColors['node-bg'],\n                    color: themeColors['node-text'],\n                },\n            },\n            {\n                selector: 'edge',\n                style: {\n                    'line-color': themeColors['edge-line'],\n                    'target-arrow-color': themeColors['edge-arrow'],\n                    color: themeColors['edge-text'],\n                },\n            },\n            {\n                selector: 'node:selected',\n                style: {\n                    'background-color': themeColors['node-selected-bg'],\n                    'border-color': themeColors['node-selected-border'],\n                },\n            },\n            {\n                selector: 'edge:selected',\n                style: {\n                    'line-color': themeColors['edge-selected'],\n                    'target-arrow-color': themeColors['edge-selected'],\n                },\n            },\n        ];\n        // Apply the themed styles with hex color resolution\n        const processedThemedStyles = processColorTokens(themedStyles, this.currentTheme);\n        this.cy.style(processedThemedStyles);\n    }\n    returnMethods() {\n        // this method is compulsory in all our third party services\n        return {\n            init: this.init.bind(this),\n            // setContainer: this.setContainer.bind(this),\n            elementClick: this.elementClick.bind(this),\n            updateData: this.updateData.bind(this),\n            getInstance: this.getInstance.bind(this),\n            setZoomLevel: this.setZoomLevel.bind(this),\n            // Enhanced cleanup methods\n            destroy: this.destroy.bind(this),\n            remove: this.remove.bind(this),\n            clear: this.clear.bind(this),\n            dispose: this.dispose.bind(this),\n            // Info panel methods\n            showInfoPanel: this.showInfoPanel.bind(this),\n            hideInfoPanel: this.hideInfoPanel.bind(this),\n            updateInfoPanel: this.updateInfoPanel.bind(this),\n            setInfoPanelPosition: this.setInfoPanelPosition.bind(this),\n            getInfoPanelData: this.getInfoPanelData.bind(this),\n            isInfoPanelVisible: this.isInfoPanelVisible.bind(this),\n            // Utility methods\n            fit: this.fit.bind(this),\n            center: this.center.bind(this),\n            zoom: this.zoom.bind(this),\n            pan: this.pan.bind(this),\n            runLayout: this.runLayout.bind(this),\n            getSelectedElements: this.getSelectedElements.bind(this),\n            selectElement: this.selectElement.bind(this),\n            unselectAll: this.unselectAll.bind(this),\n            exportData: this.exportData.bind(this),\n            importData: this.importData.bind(this),\n            // Style and theming methods\n            updateStyles: this.updateStyles.bind(this),\n            updateElementStyle: this.updateElementStyle.bind(this),\n            setTheme: this.setTheme.bind(this),\n        };\n    }\n}\n","references":["/home/mobius/Project/KYA-MVT-FOLDER/kya-instance-cytoscape-lib/node_modules/cytoscape/index.d.ts","/home/mobius/Project/KYA-MVT-FOLDER/kya-instance-cytoscape-lib/src/cytoscapeDataUtils/defaultStyles.ts","/home/mobius/Project/KYA-MVT-FOLDER/kya-instance-cytoscape-lib/src/cytoscapeDataUtils/colaLayoutDefault.ts","/home/mobius/Project/KYA-MVT-FOLDER/kya-instance-cytoscape-lib/src/cytoscapeDataUtils/themeData.ts"],"dts":{"name":"/home/mobius/Project/KYA-MVT-FOLDER/kya-instance-cytoscape-lib/node_modules/.cache/rollup-plugin-typescript2/placeholder/CytoscapeService.d.ts","writeByteOrderMark":false,"text":"import cytoscape, { Core, NodeSingular, EdgeSingular, SelectionType } from 'cytoscape';\ninterface CytoscapeConfig {\n    elements?: any[];\n    layout?: any;\n    style?: any[];\n    zoom?: number;\n    pan?: {\n        x: number;\n        y: number;\n    };\n    minZoom?: number;\n    maxZoom?: number;\n    zoomingEnabled?: boolean;\n    userZoomingEnabled?: boolean;\n    panningEnabled?: boolean;\n    userPanningEnabled?: boolean;\n    boxSelectionEnabled?: boolean;\n    selectionType?: SelectionType;\n    autoungrabify?: boolean;\n    autounselectify?: boolean;\n    onNodeClick?: {\n        state: string;\n    };\n    onEdgeClick?: (edge: EdgeSingular) => void;\n    onNodeHover?: (node: NodeSingular) => void;\n    onEdgeHover?: (edge: EdgeSingular) => void;\n    onBackgroundClick?: () => void;\n    [key: string]: any;\n    enableInfoPanel?: boolean;\n    infoPanelPosition?: string;\n}\ninterface NodeData {\n    id?: string;\n    label?: string;\n    [key: string]: any;\n}\ninterface InfoPanelData {\n    title: string;\n    content: any;\n    type: 'node' | 'edge';\n    timestamp: number;\n    position?: {\n        x: number;\n        y: number;\n    };\n}\nexport declare class CytoscapeService {\n    private cy;\n    private container;\n    private selectedElement;\n    private cyConfig;\n    private eventListeners;\n    private isDestroyed;\n    private currentTheme;\n    private infoPanel;\n    private infoPanelData;\n    private _isInfoPanelVisible;\n    init(context: HTMLElement | string, config?: CytoscapeConfig): cytoscape.Core | undefined;\n    /**\n     * Creates the info panel element\n     */\n    private createInfoPanel;\n    /**\n     * Positions the info panel near the clicked element\n     */\n    private positionPanelNearElement;\n    /**\n     * Updates the arrow position and direction\n     */\n    private updateArrowPosition;\n    /**\n     * Updates the position of the info panel\n     */\n    private updateInfoPanelPosition;\n    /**\n     * Shows the info panel with the provided data\n     */\n    showInfoPanel(data: InfoPanelData): void;\n    /**\n     * Hides the info panel\n     */\n    hideInfoPanel(): void;\n    /**\n     * Updates the content of the info panel\n     */\n    private updateInfoPanelContent;\n    /**\n     * Formats JSON content for display in a two-column layout\n     */\n    private formatJsonContent;\n    /**\n     * Capitalizes the first letter of a string\n     */\n    private capitalizeFirst;\n    /**\n     * Updates the info panel with new data\n     */\n    updateInfoPanel(data: InfoPanelData): void;\n    /**\n     * Sets the position of the info panel\n     */\n    setInfoPanelPosition(position: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'): void;\n    /**\n     * Gets the current info panel data\n     */\n    getInfoPanelData(): InfoPanelData | null;\n    /**\n     * Checks if the info panel is visible\n     */\n    isInfoPanelVisible(): boolean;\n    elementClick(context: HTMLElement): NodeData | undefined;\n    updateData(context: HTMLElement, elements: any[]): void;\n    setZoomLevel(context: HTMLElement, distance: number): void;\n    getInstance(context: HTMLElement): Core | null;\n    destroy(context?: HTMLElement): void;\n    remove(): void;\n    clear(): void;\n    dispose(): void;\n    private removeAllEventListeners;\n    fit(): void;\n    center(): void;\n    zoom(level: number): void;\n    pan(position: {\n        x: number;\n        y: number;\n    }): void;\n    runLayout(layoutOptions?: any): void;\n    getSelectedElements(): any[];\n    selectElement(elementId: string): void;\n    unselectAll(): void;\n    exportData(): any;\n    importData(data: any): void;\n    updateStyles(newStyles: any[]): void;\n    updateElementStyle(elementSelector: string, newStyle: any): void;\n    setTheme(theme: 'light' | 'dark' | string): void;\n    returnMethods(): {\n        init: (context: HTMLElement | string, config?: CytoscapeConfig) => cytoscape.Core | undefined;\n        elementClick: (context: HTMLElement) => NodeData | undefined;\n        updateData: (context: HTMLElement, elements: any[]) => void;\n        getInstance: (context: HTMLElement) => Core | null;\n        setZoomLevel: (context: HTMLElement, distance: number) => void;\n        destroy: (context?: HTMLElement) => void;\n        remove: () => void;\n        clear: () => void;\n        dispose: () => void;\n        showInfoPanel: (data: InfoPanelData) => void;\n        hideInfoPanel: () => void;\n        updateInfoPanel: (data: InfoPanelData) => void;\n        setInfoPanelPosition: (position: \"top-right\" | \"top-left\" | \"bottom-right\" | \"bottom-left\") => void;\n        getInfoPanelData: () => InfoPanelData | null;\n        isInfoPanelVisible: () => boolean;\n        fit: () => void;\n        center: () => void;\n        zoom: (level: number) => void;\n        pan: (position: {\n            x: number;\n            y: number;\n        }) => void;\n        runLayout: (layoutOptions?: any) => void;\n        getSelectedElements: () => any[];\n        selectElement: (elementId: string) => void;\n        unselectAll: () => void;\n        exportData: () => any;\n        importData: (data: any) => void;\n        updateStyles: (newStyles: any[]) => void;\n        updateElementStyle: (elementSelector: string, newStyle: any) => void;\n        setTheme: (theme: \"light\" | \"dark\" | string) => void;\n    };\n}\nexport {};\n"}}
